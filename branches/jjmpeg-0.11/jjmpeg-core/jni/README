
Code Generation
---------------

The generator is defined by the 'native-jjmpeg.conf' file, and
processed by the very ugly write-only perl script 'genjjmpeg.pl'.

This creates:
 jjmpeg-jni.c: The automatically generated bindings from the description.
  This includes jjmpeg-jni.h which needs to include everything.

 AVAbstract.java: The corresponding abstract base classes for all objects.

jjmpeg-jni.c is in turn included in jjmpeg.c, which defines the hand-rolled
native calls.

Compiling
---------

This code is compiled by scripts in jjmpeg-java/jni or jjmpeg-android/jni.

Generator Configuration
-----------------------

Unfortunately, the newer ffmpeg libraries added a whole bunch of
annoying conventions which make the binding and description of the
binding a lot more complicated.  Needing the addition of the inout and
out pseudo-keywords.

Format is one or more of the following:
class <classname>
<fields>
methods
prefix <prefix> <libraryname>
<c prototypes>
<- blank line

<classname> is the name of the C structure and the Java class
which accesses it.

Fields
------
<fields> are a list of fields:
c type,name,flags[,java name[,offset]]

 c type is the basic c type or structure (no 'struct ' though), or
 for enums, the name of the java enum.

 name is the name of the field

 flags is a list of flags
  p - public
  g - need getter
  s - need setter
  i - indexed (array)
  e - enum
  o - object (should be set for any pointer types)
  r - object must be referenced (i.e. is a struct and must be converted to a pointer)

 java name if provided is used instead of the c name - for
 when the c->java name conversion isn't consistent/desirable (e.g. union reference)

 offset is required for enum types, and indicates how far from
 '0' the first enum is.  enum types only support contigous ranges. 

Methods
-------
methods then follow, and are indicated by the optional keyword 'methods'.

prefix defines the common prefix of method names to strip from the function
name, and also defines which library the methods are loaded from (for dlopen).
'lib' is prefixed, and '.so' is suffixed the library name.

Plain C prototypes then follow, with the following limitations and alterations:
 - struct types are not allowed, only typedef'd types.
 - optional method keywords which must appear in this order
   - `internal' no auto-generated binding at all, but a dlsym internal binding
      for custom C code is generated (where dynamic linking is used)
   - `native' indicates no auto-generated binding in the public object
   - `protected' indicates the public object binding is protected
   - `static' indicates package scope, and that the method must not take the ByteBuffer
     object wrapper pointer.
 - optional argument keywords which must appear in this order
   - `out' an out-only parameter.
   - `inout' an in-out parameter.
 - out and inout parameters must have one '*' removed from their type, so that the type
   reflects the target type and not the reference.
( not implemented yet
 - array parameters must end with [], and remove one '*' from their type.
    e.g. AVDictionary **foo -> AVDictionary *foo[]
 - array parameters can have 'inout' set, if they are to be modified )
 - only a limited number of types work.  Any struct types must match one of
   the classes defined in the file, or some other java class at compile time.

A blank line is required to terminate a class definition.

Lines beggining with # are comments.
